//ALU testing 
//supports add and subtract
//nothing else should work in this module
module ALU_pass_add_sub (A, B, cntrl, result, overflow, negative, zero, carryout);

	//64 bit inputs
	input logic [63:0] A, B;
	
	//3 bit ALU control signals
	input logic [2:0] cntrl;
	
	//64 bit result output
	output logic [63:0] result; 
	
	//output flags for ALU op results
	output logic overflow, negative, zero, carryout;
	
	//holds all the things to shove into ALU control mux
	logic [7:0][63:0] ALU_inputs;
	
	//wire to determine whether to send B or ~B to the ALU
	wire [63:0] B_adj;
	
	//wire to send output of 64 bit adder to add and sub op selections
	wire [63:0] toALU;
	
	//set B into two's comp stage 1 if needed (invert bits)
	mux64x2_1 twos(.sel(cntrl[0]), .i0(B), .i1(B), .out(B_adj));
	
	//adder
	//when sub control = 1, sets B into two's comp stage 2 (add 1)
	adder64_bit add_sub(.input1(A), .input2(B_adj), .sub_control(cntrl[0]), .out(toALU), .of_flag(overflow), .co_flag(carryout));
	
	//pass output of adder to both add and subtract lines of ALU op selector
	assign ALU_inputs [2] = toALU;
	assign ALU_inputs [3] = toALU; 
	
	mux64x8_1 ALU_opSel(.in(ALU_inputs), .out(result), .ctrl(cntrl));

endmodule
